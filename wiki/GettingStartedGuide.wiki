C5 DB Migration currently supports two different approaches to database migrations:

  * Manually triggered database migration from the command-line using Maven 2
  * Auto-migration from the application during application initialization

These scenarios are described in turn below:

==Migrating using Maven==

This functionality is easy to enable in a mavenized project. First you add the Carbon Five public plugin repository:

{{{
<pluginRepositories>
  <pluginRepository>
    <id>c5-public-repository</id>
    <url>http://mvn.carbonfive.com/public</url>
  </pluginRepository>
</pluginRepositories>
}}}

And then you configure the migration plugin:

{{{
<plugin>
  <groupId>com.carbonfive</groupId>
  <artifactId>db-migration-maven-plugin</artifactId>
  <version>RELEASE</version>
  <configuration>
    <url>jdbc:mysql://dev-db/some-database</url>
    <username>dev</username>
    <password>dev</password>
  </configuration>
  <dependencies>
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.6</version>
    </dependency>
  </dependencies>
</plugin>
}}}

We've hard-coded values for url, username, and password for the sake of example.  These would most likely be properties that can be overridden for numerous environments (dev, staging, production) via maven profiles.

The plugin doesn't have dependencies on any specific JDBC drivers, so you'll have to include the dependencies which include your specific driver.

Lastly, you drop in your migration scripts into the src/main/db/migrations directory, naming them using the pattern YYYYMMDDHHMMSS_description.sql, where YYYYMMDDHHMMSS is a fourteen digit timestamp. Some examples might be:

    * 20080115200312_create_users_table.sql
    * 20080518092345_add_default_users.sql
    * 20080718214051_add_lastvisit_column.sql

The description is optional and isn’t used for anything, it’s just there so that other developers can get an idea of what a script does without having to open it.

From the command line, you can run the migration plugin like this:

{{{
$ mvn migration:migrate
}}}

If you want the plugin to also create the database, you can invoke the plugin like this:

{{{
$ mvn migration:create migration:migrate
}}}

I’ve created a simple, complete sample that shows off this functionality, it’s located on the Carbon Five public subversion repository [http://svn.carbonfive.com/public/christian/migration-sample1/trunk here]. Check it out and then read the readme.txt at the top of the project.

For more information about the maven plugin, check out the [MavenPlugin maven plugin] docs.

==Migrating from your Application==

The other usage scenario is to auto-migrate during application startup. At the core of the framework, there’s an interface called !MigrationManager which has two implementations: !DataSourceMigrationManager and !DriverManagerMigrationManager. Migration happens right after a datasource (of the javax.sql variety) is created.

Migrating from your application is as easy as instantiating one of these early in the startup cycle and invoking the migrate() method, something like this:

{{{
MigrationManager migrationManager = new
    DriverManagerMigrationManager(“com.mysql.jdbc.Driver”, “jdbc:mysql://localhost/myapp_test”, “dev”, “dev”);
migrationManager.migrate();
}}}

Of course this needs to happen before anything else in the application uses the database; we want to database to be updated completely before it’s used.

Spring is part of our standard development stack on our Java projects, and it’s easy to enforce these dependencies in Spring configuration. First we define a data source for the application:

{{{
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
  <property name="driverClassName" value="org.h2.Driver"/>
  <property name="url" value="jdbc:h2:file:~/.h2/migration_sample2_test"/>
  <property name="username" value="dev"/>
  <property name="password" value="dev"/>
</bean>
}}}

And now we declare our !MigrationManager instance. Note the ‘init-method’ attribute:

{{{
<bean id="migrationManager"
    class="com.carbonfive.db.migration.DataSourceMigrationManager"
    init-method="migrate">
  <constructor-arg ref="dataSource"/>
</bean>
}}}

And then you define something that’s going to use the defined !DataSource. Note the ‘depends-on’ attribute:

{{{
<bean id="userService"
    class="com.carbonfive.migration.sample2.UserService"
    depends-on="migrationManager">
  <constructor-arg ref="dataSource"/>
</bean>
}}}

This is obviously a little contrived for the sake of example, but you get the point. In a typical application the thing that would depend on the datasource is a Hibernate !SessionFactory.

You can check out the source code for this example on the Carbon Five public subversion repository [https://svn.carbonfive.com/public/christian/migration-sample2/trunk here].

For more information about using the migration framework programmatically, check out the [DevelopersGuide developer] docs.